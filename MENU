import pygame
import sys
import math
import random

# Inicialização do Pygame
pygame.init()

# Configurações da tela
WIDTH, HEIGHT = 1024, 768
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Reino Medieval")

# Cores
DARK_BROWN = (30, 20, 10)
GOLD = (212, 175, 55)
LIGHT_GOLD = (230, 200, 100)
DARK_GOLD = (160, 130, 40)
RED = (180, 30, 30)
DARK_RED = (120, 20, 20)
PARCHMENT = (240, 220, 180)
DARK_PARCHMENT = (200, 180, 140)
STONE_LIGHT = (180, 170, 160)
STONE_DARK = (120, 110, 100)
TORCH_LIGHT = (255, 150, 50)
TORCH_GLOW = (255, 200, 100, 100)

# Carregar fontes (tentativa)
try:
    title_font = pygame.font.Font("freesansbold.ttf", 64)
    menu_font = pygame.font.Font("freesansbold.ttf", 36)
    small_font = pygame.font.Font("freesansbold.ttf", 28)
    decorative_font = pygame.font.Font("freesansbold.ttf", 18)
except:
    title_font = pygame.font.SysFont("timesnewroman", 64, bold=True)
    menu_font = pygame.font.SysFont("timesnewroman", 36, bold=True)
    small_font = pygame.font.SysFont("timesnewroman", 28, bold=True)
    decorative_font = pygame.font.SysFont("timesnewroman", 18, italic=True)

# Textos
title_text = title_font.render("REINO MEDIEVAL", True, GOLD)
subtitle_text = decorative_font.render("A Lenda do Cavaleiro Perdido", True, LIGHT_GOLD)
menu_options = [
    "CONTINUAR",
    "CARREGAR JOGO", 
    "MAPA DO REINO",
    "OPÇÕES",
    "SAIR DO CASTELO"
]
selected_option = 0

# Efeitos de partículas para tochas
class TorchParticle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.size = random.randint(2, 6)
        self.speed = random.uniform(0.5, 2)
        self.angle = random.uniform(math.pi/2 - 0.5, math.pi/2 + 0.5)
        self.life = random.uniform(20, 60)
        self.color = (255, random.randint(100, 200), random.randint(0, 50))
        
    def update(self):
        self.x += math.cos(self.angle) * self.speed
        self.y -= math.sin(self.angle) * self.speed
        self.life -= 1
        self.size *= 0.95
        return self.life > 0
        
    def draw(self, surface):
        alpha = min(255, int(self.life * 4))
        color = (*self.color, alpha)
        particle_surf = pygame.Surface((self.size*2, self.size*2), pygame.SRCALPHA)
        pygame.draw.circle(particle_surf, color, (self.size, self.size), self.size)
        surface.blit(particle_surf, (int(self.x - self.size), int(self.y - self.size)))

# Sistema de partículas
torch_particles = []
torch_positions = [(150, 200), (WIDTH-150, 200), (150, HEIGHT-200), (WIDTH-150, HEIGHT-200)]

# Função para criar textura de pedra
def create_stone_texture():
    texture = pygame.Surface((WIDTH, HEIGHT))
    for x in range(0, WIDTH, 4):
        for y in range(0, HEIGHT, 4):
            shade = random.randint(80, 120)
            color = (shade, shade-10, shade-20)
            pygame.draw.rect(texture, color, (x, y, 4, 4))
    return texture

# Função para desenhar brasão
def draw_coat_of_arms(x, y, size):
    # Escudo
    points = [
        (x, y - size//2),
        (x + size//2, y - size//4),
        (x + size//2, y + size//4),
        (x, y + size//2),
        (x - size//2, y + size//4),
        (x - size//2, y - size//4)
    ]
    pygame.draw.polygon(screen, RED, points)
    pygame.draw.polygon(screen, DARK_GOLD, points, 3)
    
    # Leão
    pygame.draw.circle(screen, GOLD, (x, y), size//4)
    # Coroa
    crown_points = [
        (x - size//6, y - size//8),
        (x, y - size//4),
        (x + size//6, y - size//8)
    ]
    pygame.draw.polygon(screen, DARK_GOLD, crown_points)

# Função para desenhar botão ornamentado
def draw_ornate_button(text, x, y, width, height, is_selected=False, has_icon=False):
    # Cores baseadas na seleção
    base_color = LIGHT_GOLD if is_selected else GOLD
    shadow_color = DARK_GOLD
    text_color = DARK_BROWN if is_selected else (40, 25, 15)
    
    # Sombra
    shadow_rect = pygame.Rect(x+6, y+6, width, height)
    pygame.draw.rect(screen, (20, 15, 10), shadow_rect, border_radius=12)
    
    # Botão principal
    button_rect = pygame.Rect(x, y, width, height)
    pygame.draw.rect(screen, base_color, button_rect, border_radius=12)
    pygame.draw.rect(screen, shadow_color, button_rect, 4, border_radius=12)
    
    # Detalhes decorativos nos cantos
    corner_size = 15
    # Cantos superiores
    pygame.draw.line(screen, shadow_color, (x+5, y+corner_size), (x+corner_size, y+5), 3)
    pygame.draw.line(screen, shadow_color, (x+width-5, y+corner_size), (x+width-corner_size, y+5), 3)
    # Cantos inferiores
    pygame.draw.line(screen, shadow_color, (x+5, y+height-corner_size), (x+corner_size, y+height-5), 3)
    pygame.draw.line(screen, shadow_color, (x+width-5, y+height-corner_size), (x+width-corner_size, y+height-5), 3)
    
    # Texto
    text_surf = menu_font.render(text, True, text_color)
    text_rect = text_surf.get_rect(center=(x + width/2, y + height/2))
    screen.blit(text_surf, text_rect)
    
    # Ícone de seleção
    if is_selected:
        # Pontas decorativas
        arrow_size = 8
        # Esquerda
        pygame.draw.polygon(screen, DARK_RED, [
            (x - arrow_size, y + height//2),
            (x, y + height//2 - arrow_size),
            (x, y + height//2 + arrow_size)
        ])
        # Direita
        pygame.draw.polygon(screen, DARK_RED, [
            (x + width + arrow_size, y + height//2),
            (x + width, y + height//2 - arrow_size),
            (x + width, y + height//2 + arrow_size)
        ])

# Função para desenhar moldura decorativa
def draw_ornate_frame():
    # Moldura externa principal
    frame_rect = pygame.Rect(50, 50, WIDTH-100, HEIGHT-100)
    pygame.draw.rect(screen, DARK_GOLD, frame_rect, 8, border_radius=20)
    
    # Moldura interna
    inner_rect = pygame.Rect(70, 70, WIDTH-140, HEIGHT-140)
    pygame.draw.rect(screen, GOLD, inner_rect, 4, border_radius=15)
    
    # Cantos ornamentados
    corner_size = 60
    corner_thickness = 6
    
    # Canto superior esquerdo
    pygame.draw.arc(screen, GOLD, (50, 50, corner_size, corner_size), math.pi, 3*math.pi/2, corner_thickness)
    # Canto superior direito
    pygame.draw.arc(screen, GOLD, (WIDTH-50-corner_size, 50, corner_size, corner_size), 3*math.pi/2, 2*math.pi, corner_thickness)
    # Canto inferior esquerdo
    pygame.draw.arc(screen, GOLD, (50, HEIGHT-50-corner_size, corner_size, corner_size), math.pi/2, math.pi, corner_thickness)
    # Canto inferior direito
    pygame.draw.arc(screen, GOLD, (WIDTH-50-corner_size, HEIGHT-50-corner_size, corner_size, corner_size), 0, math.pi/2, corner_thickness)
    
    # Desenhar brasões nos cantos
    draw_coat_of_arms(120, 120, 80)
    draw_coat_of_arms(WIDTH-120, 120, 80)
    draw_coat_of_arms(120, HEIGHT-120, 80)
    draw_coat_of_arms(WIDTH-120, HEIGHT-120, 80)

# Função para desenhar tochas
def draw_torches():
    for x, y in torch_positions:
        # Base da tocha
        pygame.draw.rect(screen, DARK_BROWN, (x-8, y, 16, 40))
        
        # Chama
        flame_points = [
            (x, y-25),
            (x-10, y-5),
            (x-5, y-10),
            (x, y-20),
            (x+5, y-10),
            (x+10, y-5)
        ]
        pygame.draw.polygon(screen, TORCH_LIGHT, flame_points)
        
        # Adicionar partículas
        if random.random() < 0.3:
            torch_particles.append(TorchParticle(x, y-15))

# Função para desenhar diálogo de confirmação
def draw_confirmation_dialog():
    # Fundo do diálogo com textura de pergaminho
    dialog_rect = pygame.Rect(WIDTH//2-250, HEIGHT//2-120, 500, 240)
    
    # Sombra
    shadow_rect = dialog_rect.move(8, 8)
    pygame.draw.rect(screen, (20, 15, 10), shadow_rect, border_radius=20)
    
    # Pergaminho
    pygame.draw.rect(screen, PARCHMENT, dialog_rect, border_radius=20)
    pygame.draw.rect(screen, DARK_PARCHMENT, dialog_rect, 4, border_radius=20)
    
    # Detalhes do pergaminho (enrolado)
    scroll_radius = 20
    pygame.draw.rect(screen, DARK_PARCHMENT, (dialog_rect.left, dialog_rect.top, 40, dialog_rect.height), border_radius=scroll_radius)
    pygame.draw.rect(screen, DARK_PARCHMENT, (dialog_rect.right-40, dialog_rect.top, 40, dialog_rect.height), border_radius=scroll_radius)
    
    # Texto de confirmação
    confirm_text = menu_font.render("Tem certeza que deseja sair do castelo?", True, DARK_BROWN)
    confirm_rect = confirm_text.get_rect(center=(WIDTH//2, HEIGHT//2-50))
    screen.blit(confirm_text, confirm_rect)
    
    # Botões
    draw_ornate_button("SIM", WIDTH//2-150, HEIGHT//2+30, 120, 50, False)
    draw_ornate_button("NÃO", WIDTH//2+30, HEIGHT//2+30, 120, 50, True)

# Criar textura de fundo
stone_texture = create_stone_texture()

# Loop principal
clock = pygame.time.Clock()
show_confirmation = False
time_elapsed = 0

running = True
while running:
    dt = clock.tick(60) / 1000.0
    time_elapsed += dt
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.KEYDOWN:
            if not show_confirmation:
                if event.key == pygame.K_UP:
                    selected_option = (selected_option - 1) % len(menu_options)
                elif event.key == pygame.K_DOWN:
                    selected_option = (selected_option + 1) % len(menu_options)
                elif event.key == pygame.K_RETURN:
                    if menu_options[selected_option] == "SAIR DO CASTELO":
                        show_confirmation = True
                    else:
                        print(f"Selecionado: {menu_options[selected_option]}")
            else:
                if event.key == pygame.K_RETURN or event.key == pygame.K_ESCAPE:
                    show_confirmation = False
    
    # Atualizar partículas
    torch_particles = [p for p in torch_particles if p.update()]
    
    # Desenhar cena
    # Fundo com textura de pedra
    screen.blit(stone_texture, (0, 0))
    
    # Efeito de iluminação das tochas
    torch_light = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
    for x, y in torch_positions:
        radius = 150 + math.sin(time_elapsed * 3) * 10
        pygame.draw.circle(torch_light, TORCH_GLOW, (x, y), radius)
    screen.blit(torch_light, (0, 0), special_flags=pygame.BLEND_ALPHA_SDL2)
    
    # Desenhar moldura
    draw_ornate_frame()
    
    # Desenhar tochas
    draw_torches()
    
    # Desenhar partículas
    for particle in torch_particles:
        particle.draw(screen)
    
    # Título e subtítulo
    title_rect = title_text.get_rect(center=(WIDTH//2, 150))
    screen.blit(title_text, title_rect)
    
    subtitle_rect = subtitle_text.get_rect(center=(WIDTH//2, 210))
    screen.blit(subtitle_text, subtitle_rect)
    
    # Desenhar opções do menu
    button_width, button_height = 400, 60
    start_y = 280
    spacing = 80
    
    for i, option in enumerate(menu_options):
        is_selected = (i == selected_option)
        draw_ornate_button(option, WIDTH//2 - button_width//2, 
                          start_y + i * spacing, button_width, button_height, is_selected)
    
    # Rodapé decorativo
    footer_text = decorative_font.render("© 2024 Reino Medieval - Todos os direitos protegidos pelo rei", True, LIGHT_GOLD)
    footer_rect = footer_text.get_rect(center=(WIDTH//2, HEIGHT - 80))
    screen.blit(footer_text, footer_rect)
    
    # Diálogo de confirmação
    if show_confirmation:
        # Overlay escuro
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))
        
        draw_confirmation_dialog()
    
    # Atualizar tela
    pygame.display.flip()

pygame.quit()
sys.exit()